<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>there API documentation</title>
<meta name="description" content="Name:
there.py : learn how to change, for the better â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>there</code></h1>
</header>
<section id="section-intro">
<h2 id="name">Name</h2>
<p>there.py : learn how to change, for the better
</p>
<h2 id="version">Version</h2>
<p>0.2
</p>
<h2 id="usage">Usage</h2>
<p>there [options]
</p>
<h2 id="options">Options</h2>
<p>-h
Help.<br>
-v
Verbose.<br>
-r=f
Function to run.<br>
-s=n
Set random number seed [default: 1].<br>
-k=n
Speed in knots [default: 10].
</p>
<h2 id="examples">Examples</h2>
<ul>
<li>Installation: <code>sh INSTALL.md</code>
</li>
<li>Unit tests. 'pytest.py
there.py'
</li>
<li>One Unit test. <code>pytest.py -s -k tion1 there.py</code>
</li>
<li>Continual tests: <code>rerun 'pytest there.py'</code>
</li>
<li>Documentation: <code>sh DOC.md</code>
</li>
<li>Add some shell tricks: <code>sh SH.md</code>
</li>
</ul>
<h2 id="notes">Notes</h2>
<p>Simplest to tricky-est, this code divides<br>
into <code>OTHER</code>,<code>BINS</code>,<code>TABLE</code>.
</p>
<ul>
<li><code>OTHER</code> contains misc
utilities.
</li>
<li><code>ROW</code> manages sets of rows.
</li>
<li><code>BINS</code> does discretization.
</li>
</ul>
<h2 id="author">Author</h2>
<p>Tim Menzies<br>
timm@ieee.org<br>
<a href="http://menzies.us">http://menzies.us</a>
</p>
<h2 id="copyright">Copyright</h2>
<p>(c) 2020 Tim Menzies,<br>
MIT license,<br>
<a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;  
Name:
    there.py : learn how to change, for the better  
  
Version:
    0.2  
  
Usage:
    there [options]  
  
Options:
  
    -h        Help.  
    -v        Verbose.  
    -r=f      Function to run.  
    -s=n      Set random number seed [default: 1].  
    -k=n      Speed in knots [default: 10].  
  
Examples:
  
    - Installation: `sh INSTALL.md`  
    - Unit tests. &#39;pytest.py  there.py&#39;  
    - One Unit test. `pytest.py -s -k tion1 there.py`  
    - Continual tests: `rerun &#39;pytest there.py&#39;`  
    - Documentation: `sh DOC.md`  
    - Add some shell tricks: `sh SH.md`  
  
Notes:
    Simplest to tricky-est, this code divides  
    into `OTHER`,`BINS`,`TABLE`.  
  
    - `OTHER` contains misc  utilities.  
    - `ROW` manages sets of rows.  
    - `BINS` does discretization.  
  
Author:
   Tim Menzies  
   timm@ieee.org  
   http://menzies.us  
  
Copyright:
   (c) 2020 Tim Menzies,  
   MIT license,  
   https://opensource.org/licenses/MIT  
  
&#34;&#34;&#34;

from collections import defaultdict
import re
import sys
import math
import copy
import bisect
import pprint
from docopt import docopt
from random import random, seed, choice
from random import shuffle as rshuffle


# ---------------------------------------------
# Misc, lib functions
def opt(d, **types):
  &#34;&#34;&#34;Coerce dictionaries into simple keys
  whose values are of known `types`.&#34;&#34;&#34;
  d = {re.sub(r&#34;^[-]+&#34;, &#34;&#34;, k): v for k, v in d.items()}
  for k, f in types.items():
    d[k] = f(d[k])
  return o(**d)


def ako(x, c): return isinstace(x, c)
def same(x): return x
def first(a): return a[0]
def last(a): return a[-1]
def shuffle(a): rshuffle(a); return a


class o:
  &#34;&#34;&#34;LIB: Class that can pretty print; that
  can `inc`rement and `__add__` their values.&#34;&#34;&#34;
  def __init__(i, **d):
    i.__dict__.update(**d)

  def __repr__(i):
    &#34;Pretty print. Hide private keys (those starting in `_`)&#34;
    def dicts(x, seen=None):
      if isinstance(x, (tuple, list)):
        return [dicts(v, seen) for v in i]
      if isinstance(x, dict):
        return {k: dicts(x[k], seen)
                for k in x if str(k)[0] != &#34;_&#34;}
      if isinstance(x, o):
        seen = seen or {}
        j = id(x) % 128021  # ids are LONG; show them shorter.
        if x in seen:
          return f&#34;#:{j}&#34;
        seen[x] = x
        d = dicts(x.__dict__, seen)
        d[&#34;#&#34;] = j
        return d
      return x
    # -----------------------
    return re.sub(r&#34;&#39;&#34;, &#39; &#39;,
                  pprint.pformat(dicts(i.__dict__), compact=True))


class Row(o):
  &#34;&#34;&#34;
  Holds one example from a set of `rows`
  in &#39;cells&#39; (and, if the row has been descretized,
  in &#39;bins&#39;).
  &#34;&#34;&#34;
  def __init__(i, rows, cells):
    i._rows = rows
    i.cells = cells
    i.bins = cells[:]
    i.seen = False
    i.dom = 0

  def __getitem__(i, k):
    return i.cells[k]

  def better(i, j):
    c = i._rows.cols
    s1, s2, n = 0, 0, len(c.y) + 0.0001
    for k in c.y:
      x = i.bins[k]
      y = j.bins[k]
      s1 -= math.e**(c.w[k] * (x - y) / n)
      s2 -= math.e**(c.w[k] * (y - x) / n)
    return s1 / n &lt; s2 / n

  def dist(i, j, what=&#34;x&#34;):
    d, n = 0, 0
    for c in i._rows.cols[what]:
      a, b = i.cells[c], j.cells[c]
      n += 1
      if a == &#34;?&#34; and b == &#34;?&#34;:
        d = 1
      else:
        if a == &#34;?&#34;:
          a = 0 if b &gt; 0.5 else 1
        if b == &#34;?&#34;:
          b = 0 if a &gt; 0.5 else 1
      d += abs(a - b) ^ 2
    return (d / (n + 0.001))**0.5

  def status(i):
    return [i[y] for y in i._rows.cols.y]


class Rows(o):
  &#34;&#34;&#34;
  Holds many examples in `rows`.  Also, `cols` stores
  type descriptions for each column (and `cols` is built from the
  names in the first row).
  &#34;&#34;&#34;
  def __init__(i, src=[]):
    &#34;&#34;&#34;
    Create from `src`, which could be a list,
    a `.csv` file name, or a string.
    &#34;&#34;&#34;
    i.all, i._bins = [], {}
    i.cols = o(all={}, w={}, klass=None, x={}, y={}, syms={}, nums={})
    [i.add(row) for row in csv(src)]

  def add(i, row):
    &#34;The first `row` goes to the header. All the rest got to `rows`.&#34;
    i.row(row) if i.cols.all else i.header(row)

  ch = o(klass=&#34;!&#34;, num=&#34;$&#34;,
         less=&#34;&lt;&#34;, more=&#34;&gt;&#34;, skip=&#34;?&#34;,
         nums=&#34;&gt;&lt;$&#34;, goal=&#34;&lt;&gt;!,&#34;)

  def header(i, lst):
    &#34;&#34;&#34;
    Using the magic characters from `Rows.ch`, divide the columns
    into the symbols, the numbers, the x cols, the y cols, the
    klass col. Also, store them all in the `all` list.
    &#34;&#34;&#34;
    c, ch = i.cols, Rows.ch
    c.klass = -1
    for pos, txt in enumerate(lst):
      c.all[pos] = txt
      (c.nums if txt[0] in ch.nums else c.syms)[pos] = txt
      (c.y if txt[0] in ch.goal else c.x)[pos] = txt
      c.w[pos] = -1 if ch.less in txt else 1
      if ch.klass in txt:
        c.klass = pos

  def row(i, z):
    &#34;add a new row&#34;
    z = z.cells if isinstance(z, Row) else z
    i.all += [Row(i, z)]

  def bins(i, goal=None, cohen=.2):
    &#34;&#34;&#34;
    Divide ranges into  ranges that best select for `goal`.  If
    `goal=None` then just divide into sqrt(N) bins, that differ
    by more than a small amount (at least `.2*sd`).
    &#34;&#34;&#34;
    def apply2Numerics(lst, x):
      if x == &#34;?&#34;:
        return x
      for pos, bin in enumerate(lst):
        if x &lt; bin.xlo:
          break
        if bin.xlo &lt;= x &lt; bin.xhi:
          break
      return round((pos + 1) / len(lst), 2)
    # ----------------
    if len(i._bins) == 0:
      for x in i.cols.nums:
        i._bins[x] = bins = Bins.nums(
            i.all, x=x, goal=goal, cohen=cohen, y=i.cols.klass)
        for row in i.all:
          row.bins[x] = apply2Numerics(i._bins[x], row[x])
      for x in i.cols.syms:
        i._bins[x] = Bins.syms(i.all, x=x, goal=goal, y=i.cols.klass)
    return i._bins


class Bin(o):
  &#34;&#34;&#34;A `bin` is a core data structure in DUO. It
  runs from some `lo` to `hi` value in a column, It is
  associated with some `ys` values. Some bins have higher
  `val`ue than others (i.e. better predict for any
  known goal.&#34;&#34;&#34;
  def __init__(i, z=&#34;__alll__&#34;, x=0):
    i.xlo = i.xhi = z
    i.x, i.val = x, 0
    i.ys = {}

  def selects(i, row):
    &#34;&#34;&#34;Bin`s know the `x` index of the column
    they come from (so `bin`s can be used to select rows
    whose `x` values fall in between `lo` and `hi`.&#34;&#34;&#34;
    tmp = row[i.x]
    return tmp != &#34;?&#34; and i.xlo &lt;= row[i.x] &lt;= row[i.xhi]

  def score(i, all, e=0.00001):
    &#34;Score a bin by prob*support that it selects for the goal.&#34;
    yes = i.ys.get(1, 0) / (all.ys.get(1, 0) + e)
    no = i.ys.get(0, 0) / (all.ys.get(0, 0) + e)
    tmp = round(yes**2 / (yes + no + e), 3)
    i.val = tmp if tmp &gt; 0.01 else 0
    return i

  def __add__(i, j):
    &#34;Add together the numeric values in `i` and `j`.&#34;
    k = Bin(x=i.x)
    k.xlo, k.xhi = i.xlo, j.xhi
    for x, v in i.ys.items():
      k.ys[x] = v
    for x, v in j.ys.items():
      k.ys[x] = v + k.ys.get(x, 0)
    return k

  def inc(i, y, want):
    k = y == want
    i.ys[k] = i.ys.get(k, 0) + 1


class Bins:
  &#34;Bins is a farcade holding code to manage `bin`s.&#34;
  def syms(lst, x=0, y=-1, goal=None):
    &#34;Return bins for columns of symbols.&#34;
    all = Bin(x=x)
    bins = {}
    for z in lst:
      xx, yy = z[x], z[y]
      if xx != &#34;?&#34;:
        if xx not in bins:
          bins[xx] = Bin(xx, x)
        now = bins[xx]
        now.inc(yy, goal)
        all.inc(yy, goal)
    return [bin.score(all) for bin in bins.values()]

  def nums(lst, x=0, y=-1, goal=None, cohen=.3,
           enough=.5, trivial=.05):
    &#34;&#34;&#34;
    Return bins for columns of numbers. Combine two bins if
    they are separated by too small amount or if
    they predict poorly for the goal.
    &#34;&#34;&#34;
    def split():
      xlo, bins, n = 0, [Bin(0, x)], len(lst)**enough
      while n &lt; 10 and n &lt; len(lst) / 2:
        n *= 1.2
      for xhi, z in enumerate(lst):
        xx, yy = z[x], z[y]
        if xhi - xlo &gt;= n:  # split when big enough
          if len(lst) - xhi &gt;= n:  # split when enough remains after
            if xx != lst[xhi - 1][x]:  # split when values differ
              bins += [Bin(xhi, x)]
              xlo = xhi
        now = bins[-1]
        now.xhi = xhi + 1
        all.xhi = xhi + 1
        now.inc(yy, goal)
        all.inc(yy, goal)
      return [bin.score(all) for bin in bins]

    def merge(bins):
      j, tmp = 0, []
      while j &lt; len(bins):
        a = bins[j]
        if j &lt; len(bins) - 1:
          b = bins[j + 1]
          ab = (a + b).score(all)
          tooLittleDifference = (mid(b) - mid(a)) &lt; cohen
          notBetterForGoal = goal and ab.val &gt;= a.val and ab.val &gt;= b.val
          if tooLittleDifference or notBetterForGoal:
            a = ab
            j += 1
        tmp += [a]
        j += 1
      return bins if len(tmp) == len(bins) else merge(tmp)

    def mid(z): return (n(z.xlo) + n(z.xhi)) / 2
    def per(z=0.5): return lst[int(len(lst) * z)][x]
    def n(z): return lst[min(len(lst) - 1, z)][x]
    def finalize(z): z.xlo, z.xhi = n(z.xlo), n(z.xhi); return z
    # --------------------------------------------------------------
    lst = sorted((z for z in lst if z[x] != &#34;?&#34;), key=lambda z: z[x])
    all = Bin(0, x)
    cohen = cohen * (per(.9) - per(.1)) / 2.54
    return [finalize(bin) for bin in merge(split())]


class Abcd:
  &#34;&#34;&#34;Track set of actual and predictions, report precsion, accuracy,
  false alarm, recall,...
  &#34;&#34;&#34;
  def __init__(i, db=&#34;all&#34;, rx=&#34;all&#34;):
    i.db = db
    i.rx = rx
    i.yes = i.no = 0
    i.known = {}
    i.a = {}
    i.b = {}
    i.c = {}
    i.d = {}
    i.all = {}

  def __call__(i, actual, predict):
    i.knowns(actual)
    i.knowns(predict)
    if actual == predict:
      i.yes += 1
    else:
      i.no += 1
    for x in i.known:
      if actual == x:
        if predict == actual:
          i.d[x] += 1
        else:
          i.b[x] += 1
      else:
        if predict == x:
          i.c[x] += 1
        else:
          i.a[x] += 1

  def knowns(i, x):
    if not x in i.known:
      i.known[x] = i.a[x] = i.b[x] = i.c[x] = i.d[x] = 0.0
    i.known[x] += 1
    if (i.known[x] == 1):
      i.a[x] = i.yes + i.no

  def header(i):
    print(&#34;&#34;)
    print(&#39;{0:20s} {1:10s} {2:3s}  {3:3s} {4:3s} {5:3s} {6:3s} {7:3s} {8:3s} {9:3s} {10:3s} {11:3s} {12:3s} {13:10s}&#39;.format(
        &#34;db&#34;, &#34;rx&#34;, &#34;n&#34;, &#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;acc&#34;, &#34;pd&#34;, &#34;pf&#34;, &#34;prec&#34;, &#34;f&#34;, &#34;g&#34;, &#34;class&#34;))
    print(&#39;-&#39;*85)

  def report(i):
    def p(y): return int(100*y + 0.5)
    def n(y): return int(y)
    pd = pf = pn = prec = g = f = acc = 0
    for x in i.known:
      a = i.a[x]
      b = i.b[x]
      c = i.c[x]
      d = i.d[x]
      if (b+d):
        pd = 1.0*d / (b+d)
      if (a+c):
        pf = 1.0*c / (a+c)
      if (a+c):
        pn = 1.0*(b+d) / (a+c)
      if (c+d):
        prec = 1.0*d / (c+d)
      if (1-pf+pd):
        g = 2.0*(1-pf)*pd / (1-pf+pd)
      if (prec+pd):
        f = 2.0*prec*pd/(prec+pd)
      if (i.yes + i.no):
        acc = 1.0*i.yes/(i.yes+i.no)
      i.all[x] = o(pd=pd, pf=pf, prec=prec, g=g, f=f, acc=acc)
      print(&#39;{0:20s} {1:10s} {2:3d} {3:3d} {4:3d} {5:3d} {6:3d} {7:3d} {8:3d} {9:3d} {10:3d} {11:3d} {12:3d} {13:10s}&#39;.format(
          i.db, i.rx, n(b + d), n(a), n(b), n(c), n(d), p(acc), p(pd), p(pf), p(prec), p(f), p(g), x))


def smo(tab, n1=10):
  def pairs(lst):
    j = 0
    while j &lt; len(lst) - 1:
      yield lst[j], lst[j + 1]
      j += 2
  lst = shuffle(tab.rows)
  for i, j in pairs(lst[:n1]):
    i.dom += i.better(j)


class Seen(o):
  def __init__(i, rows=[], k=None, cols=None):
    i.seen, i.h, i.n = {}, {}, 0
    i.y = -1 if k is None else k
    n, y = {}, {}
    def p(z): return f&#34;{z:3.0f}&#34;
    m = 0
    for row in rows:
      m += 1
      if m &gt; 10:
        k = row.bins[i.y]
        n[k] = n.get(k, 0) + 1
        y[k] = y.get(k, 0) + (row.bins[i.y] == i.likes(row)[0])
        if m % 20 == 0:
          print(&#39;, &#39;.join([p(100*y[k]/n[k]) for k in y]))
      i.train(row)
    print(&#39;, &#39;.join([p(100*k) for k in y]))

  def known(i, row):
    y = row.bins[i.y]
    if y not in i.seen:
      i.h[y] = 0
      i.seen[y] = {x: {} for x, _ in enumerate(row)}
    i.h[y] += 1
    return i.seen[y]

  def train(i, row):
    i.n += 1
    seen = i.known(row)
    for col in seen:
      v = row.bins[col]
      seen[col][v] = seen[col].get(v, 0) + 1

  def likes(i, row, cols=None, m=2, k=1):
    out, best, all = None, -1*10**32, {}
    for klass in i.seen:
      seen = i.seen[klass]
      prior = (i.h[klass] + k) / (i.n + k*len(i.seen))
      tmp = math.log(prior)
      for col, val in i.fields(row, cols=cols or row._rows.cols.x):
        if val != &#34;?&#34;:
          inc = (seen[col].get(val, 0) + m*prior) / (i.h[klass] + m)
          tmp += math.log(inc)
      if tmp &gt; best:
        best, out = tmp, klass
      all[klass] = tmp
    return out, all

  def fields(i, x, cols=None):
    if cols:
      for col in cols:
        yield col, x.bins[col]
    elif isinstance(x, dict):
      for col, z in x.items():
        yield col, z
    else:
      for col, z in enumerate(x):
        yield col, z


def csv(src=None, f=sys.stdin):
  &#34;&#34;&#34;Read from stdio or file or string or list.  Kill whitespace or
  comments. Coerce number strings to numbers.&#34;Ignore columns if,
  on line one, the name contains &#39;?&#39;.&#34;&#34;&#34;
  def items(z):
    for y in z:
      yield y

  def strings(z):
    for y in z.splitlines():
      yield y

  def csv(z):
    with open(z) as fp:
      for y in fp:
        yield y

  def rows(z):
    for y in f(z):
      if isinstance(y, str):
        y = re.sub(r&#39;([\n\t\r ]|#.*)&#39;, &#39;&#39;, y).strip()
        if y:
          yield y.split(&#34;,&#34;)
      else:
        yield y

  def floats(a): return a if a == &#34;?&#34; else float(a)

  def nums(z):
    funs, num = None, Rows.ch.nums
    for a in z:
      if funs:
        yield [fun(a1) for fun, a1 in zip(funs, a)]
      else:
        funs = [floats if a1[0] in num else str for a1 in a]
        yield a

  def cols(src, todo=None):
    for a in src:
      todo = todo or [n for n, a1 in enumerate(a) if &#34;?&#34; not in a1]
      yield [a[n] for n in todo]

  if src:
    if isinstance(src, (list, tuple)):
      f = items
    elif isinstance(src, str):
      if src[-3:] == &#39;csv&#39;:
        f = csv
      else:
        f = strings
  for row in nums(cols(rows(src))):
    yield row</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="there.ako"><code class="name flex">
<span>def <span class="ident">ako</span></span>(<span>x, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ako(x, c): return isinstace(x, c)</code></pre>
</details>
</dd>
<dt id="there.csv"><code class="name flex">
<span>def <span class="ident">csv</span></span>(<span>src=None, f=sys.stdin)</span>
</code></dt>
<dd>
<div class="desc"><p>Read from stdio or file or string or list.
Kill whitespace or
comments. Coerce number strings to numbers."Ignore columns if,
on line one, the name contains '?'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csv(src=None, f=sys.stdin):
  &#34;&#34;&#34;Read from stdio or file or string or list.  Kill whitespace or
  comments. Coerce number strings to numbers.&#34;Ignore columns if,
  on line one, the name contains &#39;?&#39;.&#34;&#34;&#34;
  def items(z):
    for y in z:
      yield y

  def strings(z):
    for y in z.splitlines():
      yield y

  def csv(z):
    with open(z) as fp:
      for y in fp:
        yield y

  def rows(z):
    for y in f(z):
      if isinstance(y, str):
        y = re.sub(r&#39;([\n\t\r ]|#.*)&#39;, &#39;&#39;, y).strip()
        if y:
          yield y.split(&#34;,&#34;)
      else:
        yield y

  def floats(a): return a if a == &#34;?&#34; else float(a)

  def nums(z):
    funs, num = None, Rows.ch.nums
    for a in z:
      if funs:
        yield [fun(a1) for fun, a1 in zip(funs, a)]
      else:
        funs = [floats if a1[0] in num else str for a1 in a]
        yield a

  def cols(src, todo=None):
    for a in src:
      todo = todo or [n for n, a1 in enumerate(a) if &#34;?&#34; not in a1]
      yield [a[n] for n in todo]

  if src:
    if isinstance(src, (list, tuple)):
      f = items
    elif isinstance(src, str):
      if src[-3:] == &#39;csv&#39;:
        f = csv
      else:
        f = strings
  for row in nums(cols(rows(src))):
    yield row</code></pre>
</details>
</dd>
<dt id="there.first"><code class="name flex">
<span>def <span class="ident">first</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first(a): return a[0]</code></pre>
</details>
</dd>
<dt id="there.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(a): return a[-1]</code></pre>
</details>
</dd>
<dt id="there.opt"><code class="name flex">
<span>def <span class="ident">opt</span></span>(<span>d, **types)</span>
</code></dt>
<dd>
<div class="desc"><p>Coerce dictionaries into simple keys
whose values are of known <code>types</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opt(d, **types):
  &#34;&#34;&#34;Coerce dictionaries into simple keys
  whose values are of known `types`.&#34;&#34;&#34;
  d = {re.sub(r&#34;^[-]+&#34;, &#34;&#34;, k): v for k, v in d.items()}
  for k, f in types.items():
    d[k] = f(d[k])
  return o(**d)</code></pre>
</details>
</dd>
<dt id="there.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>random() -&gt; x in the interval [0, 1).</p></div>
</dd>
<dt id="there.same"><code class="name flex">
<span>def <span class="ident">same</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def same(x): return x</code></pre>
</details>
</dd>
<dt id="there.shuffle"><code class="name flex">
<span>def <span class="ident">shuffle</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle(a): rshuffle(a); return a</code></pre>
</details>
</dd>
<dt id="there.smo"><code class="name flex">
<span>def <span class="ident">smo</span></span>(<span>tab, n1=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smo(tab, n1=10):
  def pairs(lst):
    j = 0
    while j &lt; len(lst) - 1:
      yield lst[j], lst[j + 1]
      j += 2
  lst = shuffle(tab.rows)
  for i, j in pairs(lst[:n1]):
    i.dom += i.better(j)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="there.Abcd"><code class="flex name class">
<span>class <span class="ident">Abcd</span></span>
<span>(</span><span>db='all', rx='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Track set of actual and predictions, report precsion, accuracy,
false alarm, recall,&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Abcd:
  &#34;&#34;&#34;Track set of actual and predictions, report precsion, accuracy,
  false alarm, recall,...
  &#34;&#34;&#34;
  def __init__(i, db=&#34;all&#34;, rx=&#34;all&#34;):
    i.db = db
    i.rx = rx
    i.yes = i.no = 0
    i.known = {}
    i.a = {}
    i.b = {}
    i.c = {}
    i.d = {}
    i.all = {}

  def __call__(i, actual, predict):
    i.knowns(actual)
    i.knowns(predict)
    if actual == predict:
      i.yes += 1
    else:
      i.no += 1
    for x in i.known:
      if actual == x:
        if predict == actual:
          i.d[x] += 1
        else:
          i.b[x] += 1
      else:
        if predict == x:
          i.c[x] += 1
        else:
          i.a[x] += 1

  def knowns(i, x):
    if not x in i.known:
      i.known[x] = i.a[x] = i.b[x] = i.c[x] = i.d[x] = 0.0
    i.known[x] += 1
    if (i.known[x] == 1):
      i.a[x] = i.yes + i.no

  def header(i):
    print(&#34;&#34;)
    print(&#39;{0:20s} {1:10s} {2:3s}  {3:3s} {4:3s} {5:3s} {6:3s} {7:3s} {8:3s} {9:3s} {10:3s} {11:3s} {12:3s} {13:10s}&#39;.format(
        &#34;db&#34;, &#34;rx&#34;, &#34;n&#34;, &#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;acc&#34;, &#34;pd&#34;, &#34;pf&#34;, &#34;prec&#34;, &#34;f&#34;, &#34;g&#34;, &#34;class&#34;))
    print(&#39;-&#39;*85)

  def report(i):
    def p(y): return int(100*y + 0.5)
    def n(y): return int(y)
    pd = pf = pn = prec = g = f = acc = 0
    for x in i.known:
      a = i.a[x]
      b = i.b[x]
      c = i.c[x]
      d = i.d[x]
      if (b+d):
        pd = 1.0*d / (b+d)
      if (a+c):
        pf = 1.0*c / (a+c)
      if (a+c):
        pn = 1.0*(b+d) / (a+c)
      if (c+d):
        prec = 1.0*d / (c+d)
      if (1-pf+pd):
        g = 2.0*(1-pf)*pd / (1-pf+pd)
      if (prec+pd):
        f = 2.0*prec*pd/(prec+pd)
      if (i.yes + i.no):
        acc = 1.0*i.yes/(i.yes+i.no)
      i.all[x] = o(pd=pd, pf=pf, prec=prec, g=g, f=f, acc=acc)
      print(&#39;{0:20s} {1:10s} {2:3d} {3:3d} {4:3d} {5:3d} {6:3d} {7:3d} {8:3d} {9:3d} {10:3d} {11:3d} {12:3d} {13:10s}&#39;.format(
          i.db, i.rx, n(b + d), n(a), n(b), n(c), n(d), p(acc), p(pd), p(pf), p(prec), p(f), p(g), x))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="there.Abcd.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(i):
  print(&#34;&#34;)
  print(&#39;{0:20s} {1:10s} {2:3s}  {3:3s} {4:3s} {5:3s} {6:3s} {7:3s} {8:3s} {9:3s} {10:3s} {11:3s} {12:3s} {13:10s}&#39;.format(
      &#34;db&#34;, &#34;rx&#34;, &#34;n&#34;, &#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;acc&#34;, &#34;pd&#34;, &#34;pf&#34;, &#34;prec&#34;, &#34;f&#34;, &#34;g&#34;, &#34;class&#34;))
  print(&#39;-&#39;*85)</code></pre>
</details>
</dd>
<dt id="there.Abcd.knowns"><code class="name flex">
<span>def <span class="ident">knowns</span></span>(<span>i, x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def knowns(i, x):
  if not x in i.known:
    i.known[x] = i.a[x] = i.b[x] = i.c[x] = i.d[x] = 0.0
  i.known[x] += 1
  if (i.known[x] == 1):
    i.a[x] = i.yes + i.no</code></pre>
</details>
</dd>
<dt id="there.Abcd.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(i):
  def p(y): return int(100*y + 0.5)
  def n(y): return int(y)
  pd = pf = pn = prec = g = f = acc = 0
  for x in i.known:
    a = i.a[x]
    b = i.b[x]
    c = i.c[x]
    d = i.d[x]
    if (b+d):
      pd = 1.0*d / (b+d)
    if (a+c):
      pf = 1.0*c / (a+c)
    if (a+c):
      pn = 1.0*(b+d) / (a+c)
    if (c+d):
      prec = 1.0*d / (c+d)
    if (1-pf+pd):
      g = 2.0*(1-pf)*pd / (1-pf+pd)
    if (prec+pd):
      f = 2.0*prec*pd/(prec+pd)
    if (i.yes + i.no):
      acc = 1.0*i.yes/(i.yes+i.no)
    i.all[x] = o(pd=pd, pf=pf, prec=prec, g=g, f=f, acc=acc)
    print(&#39;{0:20s} {1:10s} {2:3d} {3:3d} {4:3d} {5:3d} {6:3d} {7:3d} {8:3d} {9:3d} {10:3d} {11:3d} {12:3d} {13:10s}&#39;.format(
        i.db, i.rx, n(b + d), n(a), n(b), n(c), n(d), p(acc), p(pd), p(pf), p(prec), p(f), p(g), x))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="there.Bin"><code class="flex name class">
<span>class <span class="ident">Bin</span></span>
<span>(</span><span>z='__alll__', x=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A <code>bin</code> is a core data structure in DUO. It
runs from some <code>lo</code> to <code>hi</code> value in a column, It is
associated with some <code>ys</code> values. Some bins have higher
<code>val</code>ue than others (i.e. better predict for any
known goal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bin(o):
  &#34;&#34;&#34;A `bin` is a core data structure in DUO. It
  runs from some `lo` to `hi` value in a column, It is
  associated with some `ys` values. Some bins have higher
  `val`ue than others (i.e. better predict for any
  known goal.&#34;&#34;&#34;
  def __init__(i, z=&#34;__alll__&#34;, x=0):
    i.xlo = i.xhi = z
    i.x, i.val = x, 0
    i.ys = {}

  def selects(i, row):
    &#34;&#34;&#34;Bin`s know the `x` index of the column
    they come from (so `bin`s can be used to select rows
    whose `x` values fall in between `lo` and `hi`.&#34;&#34;&#34;
    tmp = row[i.x]
    return tmp != &#34;?&#34; and i.xlo &lt;= row[i.x] &lt;= row[i.xhi]

  def score(i, all, e=0.00001):
    &#34;Score a bin by prob*support that it selects for the goal.&#34;
    yes = i.ys.get(1, 0) / (all.ys.get(1, 0) + e)
    no = i.ys.get(0, 0) / (all.ys.get(0, 0) + e)
    tmp = round(yes**2 / (yes + no + e), 3)
    i.val = tmp if tmp &gt; 0.01 else 0
    return i

  def __add__(i, j):
    &#34;Add together the numeric values in `i` and `j`.&#34;
    k = Bin(x=i.x)
    k.xlo, k.xhi = i.xlo, j.xhi
    for x, v in i.ys.items():
      k.ys[x] = v
    for x, v in j.ys.items():
      k.ys[x] = v + k.ys.get(x, 0)
    return k

  def inc(i, y, want):
    k = y == want
    i.ys[k] = i.ys.get(k, 0) + 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="there.o" href="#there.o">o</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="there.Bin.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>i, y, want)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inc(i, y, want):
  k = y == want
  i.ys[k] = i.ys.get(k, 0) + 1</code></pre>
</details>
</dd>
<dt id="there.Bin.score"><code class="name flex">
<span>def <span class="ident">score</span></span>(<span>i, all, e=1e-05)</span>
</code></dt>
<dd>
<div class="desc"><p>Score a bin by prob*support that it selects for the goal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score(i, all, e=0.00001):
  &#34;Score a bin by prob*support that it selects for the goal.&#34;
  yes = i.ys.get(1, 0) / (all.ys.get(1, 0) + e)
  no = i.ys.get(0, 0) / (all.ys.get(0, 0) + e)
  tmp = round(yes**2 / (yes + no + e), 3)
  i.val = tmp if tmp &gt; 0.01 else 0
  return i</code></pre>
</details>
</dd>
<dt id="there.Bin.selects"><code class="name flex">
<span>def <span class="ident">selects</span></span>(<span>i, row)</span>
</code></dt>
<dd>
<div class="desc"><p>Bin<code>s know the </code>x` index of the column
they come from (so <code>bin</code>s can be used to select rows
whose <code>x</code> values fall in between <code>lo</code> and <code>hi</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selects(i, row):
  &#34;&#34;&#34;Bin`s know the `x` index of the column
  they come from (so `bin`s can be used to select rows
  whose `x` values fall in between `lo` and `hi`.&#34;&#34;&#34;
  tmp = row[i.x]
  return tmp != &#34;?&#34; and i.xlo &lt;= row[i.x] &lt;= row[i.xhi]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="there.Bins"><code class="flex name class">
<span>class <span class="ident">Bins</span></span>
</code></dt>
<dd>
<div class="desc"><p>Bins is a farcade holding code to manage <code>bin</code>s.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bins:
  &#34;Bins is a farcade holding code to manage `bin`s.&#34;
  def syms(lst, x=0, y=-1, goal=None):
    &#34;Return bins for columns of symbols.&#34;
    all = Bin(x=x)
    bins = {}
    for z in lst:
      xx, yy = z[x], z[y]
      if xx != &#34;?&#34;:
        if xx not in bins:
          bins[xx] = Bin(xx, x)
        now = bins[xx]
        now.inc(yy, goal)
        all.inc(yy, goal)
    return [bin.score(all) for bin in bins.values()]

  def nums(lst, x=0, y=-1, goal=None, cohen=.3,
           enough=.5, trivial=.05):
    &#34;&#34;&#34;
    Return bins for columns of numbers. Combine two bins if
    they are separated by too small amount or if
    they predict poorly for the goal.
    &#34;&#34;&#34;
    def split():
      xlo, bins, n = 0, [Bin(0, x)], len(lst)**enough
      while n &lt; 10 and n &lt; len(lst) / 2:
        n *= 1.2
      for xhi, z in enumerate(lst):
        xx, yy = z[x], z[y]
        if xhi - xlo &gt;= n:  # split when big enough
          if len(lst) - xhi &gt;= n:  # split when enough remains after
            if xx != lst[xhi - 1][x]:  # split when values differ
              bins += [Bin(xhi, x)]
              xlo = xhi
        now = bins[-1]
        now.xhi = xhi + 1
        all.xhi = xhi + 1
        now.inc(yy, goal)
        all.inc(yy, goal)
      return [bin.score(all) for bin in bins]

    def merge(bins):
      j, tmp = 0, []
      while j &lt; len(bins):
        a = bins[j]
        if j &lt; len(bins) - 1:
          b = bins[j + 1]
          ab = (a + b).score(all)
          tooLittleDifference = (mid(b) - mid(a)) &lt; cohen
          notBetterForGoal = goal and ab.val &gt;= a.val and ab.val &gt;= b.val
          if tooLittleDifference or notBetterForGoal:
            a = ab
            j += 1
        tmp += [a]
        j += 1
      return bins if len(tmp) == len(bins) else merge(tmp)

    def mid(z): return (n(z.xlo) + n(z.xhi)) / 2
    def per(z=0.5): return lst[int(len(lst) * z)][x]
    def n(z): return lst[min(len(lst) - 1, z)][x]
    def finalize(z): z.xlo, z.xhi = n(z.xlo), n(z.xhi); return z
    # --------------------------------------------------------------
    lst = sorted((z for z in lst if z[x] != &#34;?&#34;), key=lambda z: z[x])
    all = Bin(0, x)
    cohen = cohen * (per(.9) - per(.1)) / 2.54
    return [finalize(bin) for bin in merge(split())]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="there.Bins.nums"><code class="name flex">
<span>def <span class="ident">nums</span></span>(<span>lst, x=0, y=-1, goal=None, cohen=0.3, enough=0.5, trivial=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bins for columns of numbers. Combine two bins if
they are separated by too small amount or if
they predict poorly for the goal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nums(lst, x=0, y=-1, goal=None, cohen=.3,
         enough=.5, trivial=.05):
  &#34;&#34;&#34;
  Return bins for columns of numbers. Combine two bins if
  they are separated by too small amount or if
  they predict poorly for the goal.
  &#34;&#34;&#34;
  def split():
    xlo, bins, n = 0, [Bin(0, x)], len(lst)**enough
    while n &lt; 10 and n &lt; len(lst) / 2:
      n *= 1.2
    for xhi, z in enumerate(lst):
      xx, yy = z[x], z[y]
      if xhi - xlo &gt;= n:  # split when big enough
        if len(lst) - xhi &gt;= n:  # split when enough remains after
          if xx != lst[xhi - 1][x]:  # split when values differ
            bins += [Bin(xhi, x)]
            xlo = xhi
      now = bins[-1]
      now.xhi = xhi + 1
      all.xhi = xhi + 1
      now.inc(yy, goal)
      all.inc(yy, goal)
    return [bin.score(all) for bin in bins]

  def merge(bins):
    j, tmp = 0, []
    while j &lt; len(bins):
      a = bins[j]
      if j &lt; len(bins) - 1:
        b = bins[j + 1]
        ab = (a + b).score(all)
        tooLittleDifference = (mid(b) - mid(a)) &lt; cohen
        notBetterForGoal = goal and ab.val &gt;= a.val and ab.val &gt;= b.val
        if tooLittleDifference or notBetterForGoal:
          a = ab
          j += 1
      tmp += [a]
      j += 1
    return bins if len(tmp) == len(bins) else merge(tmp)

  def mid(z): return (n(z.xlo) + n(z.xhi)) / 2
  def per(z=0.5): return lst[int(len(lst) * z)][x]
  def n(z): return lst[min(len(lst) - 1, z)][x]
  def finalize(z): z.xlo, z.xhi = n(z.xlo), n(z.xhi); return z
  # --------------------------------------------------------------
  lst = sorted((z for z in lst if z[x] != &#34;?&#34;), key=lambda z: z[x])
  all = Bin(0, x)
  cohen = cohen * (per(.9) - per(.1)) / 2.54
  return [finalize(bin) for bin in merge(split())]</code></pre>
</details>
</dd>
<dt id="there.Bins.syms"><code class="name flex">
<span>def <span class="ident">syms</span></span>(<span>lst, x=0, y=-1, goal=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bins for columns of symbols.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syms(lst, x=0, y=-1, goal=None):
  &#34;Return bins for columns of symbols.&#34;
  all = Bin(x=x)
  bins = {}
  for z in lst:
    xx, yy = z[x], z[y]
    if xx != &#34;?&#34;:
      if xx not in bins:
        bins[xx] = Bin(xx, x)
      now = bins[xx]
      now.inc(yy, goal)
      all.inc(yy, goal)
  return [bin.score(all) for bin in bins.values()]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="there.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>rows, cells)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds one example from a set of <code>rows</code>
in 'cells' (and, if the row has been descretized,
in 'bins').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Row(o):
  &#34;&#34;&#34;
  Holds one example from a set of `rows`
  in &#39;cells&#39; (and, if the row has been descretized,
  in &#39;bins&#39;).
  &#34;&#34;&#34;
  def __init__(i, rows, cells):
    i._rows = rows
    i.cells = cells
    i.bins = cells[:]
    i.seen = False
    i.dom = 0

  def __getitem__(i, k):
    return i.cells[k]

  def better(i, j):
    c = i._rows.cols
    s1, s2, n = 0, 0, len(c.y) + 0.0001
    for k in c.y:
      x = i.bins[k]
      y = j.bins[k]
      s1 -= math.e**(c.w[k] * (x - y) / n)
      s2 -= math.e**(c.w[k] * (y - x) / n)
    return s1 / n &lt; s2 / n

  def dist(i, j, what=&#34;x&#34;):
    d, n = 0, 0
    for c in i._rows.cols[what]:
      a, b = i.cells[c], j.cells[c]
      n += 1
      if a == &#34;?&#34; and b == &#34;?&#34;:
        d = 1
      else:
        if a == &#34;?&#34;:
          a = 0 if b &gt; 0.5 else 1
        if b == &#34;?&#34;:
          b = 0 if a &gt; 0.5 else 1
      d += abs(a - b) ^ 2
    return (d / (n + 0.001))**0.5

  def status(i):
    return [i[y] for y in i._rows.cols.y]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="there.o" href="#there.o">o</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="there.Row.better"><code class="name flex">
<span>def <span class="ident">better</span></span>(<span>i, j)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def better(i, j):
  c = i._rows.cols
  s1, s2, n = 0, 0, len(c.y) + 0.0001
  for k in c.y:
    x = i.bins[k]
    y = j.bins[k]
    s1 -= math.e**(c.w[k] * (x - y) / n)
    s2 -= math.e**(c.w[k] * (y - x) / n)
  return s1 / n &lt; s2 / n</code></pre>
</details>
</dd>
<dt id="there.Row.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>i, j, what='x')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist(i, j, what=&#34;x&#34;):
  d, n = 0, 0
  for c in i._rows.cols[what]:
    a, b = i.cells[c], j.cells[c]
    n += 1
    if a == &#34;?&#34; and b == &#34;?&#34;:
      d = 1
    else:
      if a == &#34;?&#34;:
        a = 0 if b &gt; 0.5 else 1
      if b == &#34;?&#34;:
        b = 0 if a &gt; 0.5 else 1
    d += abs(a - b) ^ 2
  return (d / (n + 0.001))**0.5</code></pre>
</details>
</dd>
<dt id="there.Row.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(i):
  return [i[y] for y in i._rows.cols.y]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="there.Rows"><code class="flex name class">
<span>class <span class="ident">Rows</span></span>
<span>(</span><span>src=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Holds many examples in <code>rows</code>.
Also, <code>cols</code> stores
type descriptions for each column (and <code>cols</code> is built from the
names in the first row).</p>
<p>Create from <code>src</code>, which could be a list,
a <code>.<a title="there.csv" href="#there.csv">csv()</a></code> file name, or a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rows(o):
  &#34;&#34;&#34;
  Holds many examples in `rows`.  Also, `cols` stores
  type descriptions for each column (and `cols` is built from the
  names in the first row).
  &#34;&#34;&#34;
  def __init__(i, src=[]):
    &#34;&#34;&#34;
    Create from `src`, which could be a list,
    a `.csv` file name, or a string.
    &#34;&#34;&#34;
    i.all, i._bins = [], {}
    i.cols = o(all={}, w={}, klass=None, x={}, y={}, syms={}, nums={})
    [i.add(row) for row in csv(src)]

  def add(i, row):
    &#34;The first `row` goes to the header. All the rest got to `rows`.&#34;
    i.row(row) if i.cols.all else i.header(row)

  ch = o(klass=&#34;!&#34;, num=&#34;$&#34;,
         less=&#34;&lt;&#34;, more=&#34;&gt;&#34;, skip=&#34;?&#34;,
         nums=&#34;&gt;&lt;$&#34;, goal=&#34;&lt;&gt;!,&#34;)

  def header(i, lst):
    &#34;&#34;&#34;
    Using the magic characters from `Rows.ch`, divide the columns
    into the symbols, the numbers, the x cols, the y cols, the
    klass col. Also, store them all in the `all` list.
    &#34;&#34;&#34;
    c, ch = i.cols, Rows.ch
    c.klass = -1
    for pos, txt in enumerate(lst):
      c.all[pos] = txt
      (c.nums if txt[0] in ch.nums else c.syms)[pos] = txt
      (c.y if txt[0] in ch.goal else c.x)[pos] = txt
      c.w[pos] = -1 if ch.less in txt else 1
      if ch.klass in txt:
        c.klass = pos

  def row(i, z):
    &#34;add a new row&#34;
    z = z.cells if isinstance(z, Row) else z
    i.all += [Row(i, z)]

  def bins(i, goal=None, cohen=.2):
    &#34;&#34;&#34;
    Divide ranges into  ranges that best select for `goal`.  If
    `goal=None` then just divide into sqrt(N) bins, that differ
    by more than a small amount (at least `.2*sd`).
    &#34;&#34;&#34;
    def apply2Numerics(lst, x):
      if x == &#34;?&#34;:
        return x
      for pos, bin in enumerate(lst):
        if x &lt; bin.xlo:
          break
        if bin.xlo &lt;= x &lt; bin.xhi:
          break
      return round((pos + 1) / len(lst), 2)
    # ----------------
    if len(i._bins) == 0:
      for x in i.cols.nums:
        i._bins[x] = bins = Bins.nums(
            i.all, x=x, goal=goal, cohen=cohen, y=i.cols.klass)
        for row in i.all:
          row.bins[x] = apply2Numerics(i._bins[x], row[x])
      for x in i.cols.syms:
        i._bins[x] = Bins.syms(i.all, x=x, goal=goal, y=i.cols.klass)
    return i._bins</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="there.o" href="#there.o">o</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="there.Rows.ch"><code class="name">var <span class="ident">ch</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="there.Rows.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>i, row)</span>
</code></dt>
<dd>
<div class="desc"><p>The first <code>row</code> goes to the header. All the rest got to <code>rows</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(i, row):
  &#34;The first `row` goes to the header. All the rest got to `rows`.&#34;
  i.row(row) if i.cols.all else i.header(row)</code></pre>
</details>
</dd>
<dt id="there.Rows.bins"><code class="name flex">
<span>def <span class="ident">bins</span></span>(<span>i, goal=None, cohen=0.2)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide ranges into
ranges that best select for <code>goal</code>.
If
<code>goal=None</code> then just divide into sqrt(N) bins, that differ
by more than a small amount (at least <code>.2*sd</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bins(i, goal=None, cohen=.2):
  &#34;&#34;&#34;
  Divide ranges into  ranges that best select for `goal`.  If
  `goal=None` then just divide into sqrt(N) bins, that differ
  by more than a small amount (at least `.2*sd`).
  &#34;&#34;&#34;
  def apply2Numerics(lst, x):
    if x == &#34;?&#34;:
      return x
    for pos, bin in enumerate(lst):
      if x &lt; bin.xlo:
        break
      if bin.xlo &lt;= x &lt; bin.xhi:
        break
    return round((pos + 1) / len(lst), 2)
  # ----------------
  if len(i._bins) == 0:
    for x in i.cols.nums:
      i._bins[x] = bins = Bins.nums(
          i.all, x=x, goal=goal, cohen=cohen, y=i.cols.klass)
      for row in i.all:
        row.bins[x] = apply2Numerics(i._bins[x], row[x])
    for x in i.cols.syms:
      i._bins[x] = Bins.syms(i.all, x=x, goal=goal, y=i.cols.klass)
  return i._bins</code></pre>
</details>
</dd>
<dt id="there.Rows.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>i, lst)</span>
</code></dt>
<dd>
<div class="desc"><p>Using the magic characters from <code><a title="there.Rows.ch" href="#there.Rows.ch">Rows.ch</a></code>, divide the columns
into the symbols, the numbers, the x cols, the y cols, the
klass col. Also, store them all in the <code>all</code> list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(i, lst):
  &#34;&#34;&#34;
  Using the magic characters from `Rows.ch`, divide the columns
  into the symbols, the numbers, the x cols, the y cols, the
  klass col. Also, store them all in the `all` list.
  &#34;&#34;&#34;
  c, ch = i.cols, Rows.ch
  c.klass = -1
  for pos, txt in enumerate(lst):
    c.all[pos] = txt
    (c.nums if txt[0] in ch.nums else c.syms)[pos] = txt
    (c.y if txt[0] in ch.goal else c.x)[pos] = txt
    c.w[pos] = -1 if ch.less in txt else 1
    if ch.klass in txt:
      c.klass = pos</code></pre>
</details>
</dd>
<dt id="there.Rows.row"><code class="name flex">
<span>def <span class="ident">row</span></span>(<span>i, z)</span>
</code></dt>
<dd>
<div class="desc"><p>add a new row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row(i, z):
  &#34;add a new row&#34;
  z = z.cells if isinstance(z, Row) else z
  i.all += [Row(i, z)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="there.Seen"><code class="flex name class">
<span>class <span class="ident">Seen</span></span>
<span>(</span><span>rows=[], k=None, cols=None)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: Class that can pretty print; that
can <code>inc</code>rement and <code>__add__</code> their values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Seen(o):
  def __init__(i, rows=[], k=None, cols=None):
    i.seen, i.h, i.n = {}, {}, 0
    i.y = -1 if k is None else k
    n, y = {}, {}
    def p(z): return f&#34;{z:3.0f}&#34;
    m = 0
    for row in rows:
      m += 1
      if m &gt; 10:
        k = row.bins[i.y]
        n[k] = n.get(k, 0) + 1
        y[k] = y.get(k, 0) + (row.bins[i.y] == i.likes(row)[0])
        if m % 20 == 0:
          print(&#39;, &#39;.join([p(100*y[k]/n[k]) for k in y]))
      i.train(row)
    print(&#39;, &#39;.join([p(100*k) for k in y]))

  def known(i, row):
    y = row.bins[i.y]
    if y not in i.seen:
      i.h[y] = 0
      i.seen[y] = {x: {} for x, _ in enumerate(row)}
    i.h[y] += 1
    return i.seen[y]

  def train(i, row):
    i.n += 1
    seen = i.known(row)
    for col in seen:
      v = row.bins[col]
      seen[col][v] = seen[col].get(v, 0) + 1

  def likes(i, row, cols=None, m=2, k=1):
    out, best, all = None, -1*10**32, {}
    for klass in i.seen:
      seen = i.seen[klass]
      prior = (i.h[klass] + k) / (i.n + k*len(i.seen))
      tmp = math.log(prior)
      for col, val in i.fields(row, cols=cols or row._rows.cols.x):
        if val != &#34;?&#34;:
          inc = (seen[col].get(val, 0) + m*prior) / (i.h[klass] + m)
          tmp += math.log(inc)
      if tmp &gt; best:
        best, out = tmp, klass
      all[klass] = tmp
    return out, all

  def fields(i, x, cols=None):
    if cols:
      for col in cols:
        yield col, x.bins[col]
    elif isinstance(x, dict):
      for col, z in x.items():
        yield col, z
    else:
      for col, z in enumerate(x):
        yield col, z</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="there.o" href="#there.o">o</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="there.Seen.fields"><code class="name flex">
<span>def <span class="ident">fields</span></span>(<span>i, x, cols=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fields(i, x, cols=None):
  if cols:
    for col in cols:
      yield col, x.bins[col]
  elif isinstance(x, dict):
    for col, z in x.items():
      yield col, z
  else:
    for col, z in enumerate(x):
      yield col, z</code></pre>
</details>
</dd>
<dt id="there.Seen.known"><code class="name flex">
<span>def <span class="ident">known</span></span>(<span>i, row)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def known(i, row):
  y = row.bins[i.y]
  if y not in i.seen:
    i.h[y] = 0
    i.seen[y] = {x: {} for x, _ in enumerate(row)}
  i.h[y] += 1
  return i.seen[y]</code></pre>
</details>
</dd>
<dt id="there.Seen.likes"><code class="name flex">
<span>def <span class="ident">likes</span></span>(<span>i, row, cols=None, m=2, k=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def likes(i, row, cols=None, m=2, k=1):
  out, best, all = None, -1*10**32, {}
  for klass in i.seen:
    seen = i.seen[klass]
    prior = (i.h[klass] + k) / (i.n + k*len(i.seen))
    tmp = math.log(prior)
    for col, val in i.fields(row, cols=cols or row._rows.cols.x):
      if val != &#34;?&#34;:
        inc = (seen[col].get(val, 0) + m*prior) / (i.h[klass] + m)
        tmp += math.log(inc)
    if tmp &gt; best:
      best, out = tmp, klass
    all[klass] = tmp
  return out, all</code></pre>
</details>
</dd>
<dt id="there.Seen.train"><code class="name flex">
<span>def <span class="ident">train</span></span>(<span>i, row)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train(i, row):
  i.n += 1
  seen = i.known(row)
  for col in seen:
    v = row.bins[col]
    seen[col][v] = seen[col].get(v, 0) + 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="there.o"><code class="flex name class">
<span>class <span class="ident">o</span></span>
<span>(</span><span>**d)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: Class that can pretty print; that
can <code>inc</code>rement and <code>__add__</code> their values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class o:
  &#34;&#34;&#34;LIB: Class that can pretty print; that
  can `inc`rement and `__add__` their values.&#34;&#34;&#34;
  def __init__(i, **d):
    i.__dict__.update(**d)

  def __repr__(i):
    &#34;Pretty print. Hide private keys (those starting in `_`)&#34;
    def dicts(x, seen=None):
      if isinstance(x, (tuple, list)):
        return [dicts(v, seen) for v in i]
      if isinstance(x, dict):
        return {k: dicts(x[k], seen)
                for k in x if str(k)[0] != &#34;_&#34;}
      if isinstance(x, o):
        seen = seen or {}
        j = id(x) % 128021  # ids are LONG; show them shorter.
        if x in seen:
          return f&#34;#:{j}&#34;
        seen[x] = x
        d = dicts(x.__dict__, seen)
        d[&#34;#&#34;] = j
        return d
      return x
    # -----------------------
    return re.sub(r&#34;&#39;&#34;, &#39; &#39;,
                  pprint.pformat(dicts(i.__dict__), compact=True))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="there.Bin" href="#there.Bin">Bin</a></li>
<li><a title="there.Row" href="#there.Row">Row</a></li>
<li><a title="there.Rows" href="#there.Rows">Rows</a></li>
<li><a title="there.Seen" href="#there.Seen">Seen</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<center>
<img src="pair.png" width=500><br>
<p><a href="LICENSE.md">&copy; 2020</a>, Tim Menzies<br>
<a href="mailto:timm@ieee.org">timm@ieee.org</a><br>
<a href="http://menzies.us">http://menzies.us</a>
</p>
<p>
"Give me the fruitful error any time,
full of seeds, bursting with its own
corrections. You can keep your sterile
truth for yourself."
-&nbsp;Vilfredo&nbsp;Pareto</p>
<p>
<img src="https://img.shields.io/badge/purpose-ai%20,%20se-blueviolet">
<a href="https://github.com/timm/bnbad/blob/master/LICENSE.md"><img
alt="License" src="https://img.shields.io/badge/license-mit-red"></a>
</p>
<p>
<img alt="Python" src="https://img.shields.io/badge/python-v3.8-blue">
<a href="https://pep8.readthedocs.io/en/release-1.7.x/intro.html#error-codes"><img alt="Style" src="https://img.shields.io/badge/style-pep8-yellow"></a>
<a href="https://flake8.pycqa.org/en/latest/user/error-codes.html"><img alt="syntax" src="https://img.shields.io/badge/syntax-pyflake8-orange"></a>
</p>
<p>
<a href="https://github.com/timm/bnbad/blob/master/README.md"><img src="github.png" width=40></a>
<a href="https://github.com/timm/bnbad/archive/master.zip"> <img src="zip.png" width=40></a>
</p>
</center>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="there.ako" href="#there.ako">ako</a></code></li>
<li><code><a title="there.csv" href="#there.csv">csv</a></code></li>
<li><code><a title="there.first" href="#there.first">first</a></code></li>
<li><code><a title="there.last" href="#there.last">last</a></code></li>
<li><code><a title="there.opt" href="#there.opt">opt</a></code></li>
<li><code><a title="there.random" href="#there.random">random</a></code></li>
<li><code><a title="there.same" href="#there.same">same</a></code></li>
<li><code><a title="there.shuffle" href="#there.shuffle">shuffle</a></code></li>
<li><code><a title="there.smo" href="#there.smo">smo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="there.Abcd" href="#there.Abcd">Abcd</a></code></h4>
<ul class="">
<li><code><a title="there.Abcd.header" href="#there.Abcd.header">header</a></code></li>
<li><code><a title="there.Abcd.knowns" href="#there.Abcd.knowns">knowns</a></code></li>
<li><code><a title="there.Abcd.report" href="#there.Abcd.report">report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="there.Bin" href="#there.Bin">Bin</a></code></h4>
<ul class="">
<li><code><a title="there.Bin.inc" href="#there.Bin.inc">inc</a></code></li>
<li><code><a title="there.Bin.score" href="#there.Bin.score">score</a></code></li>
<li><code><a title="there.Bin.selects" href="#there.Bin.selects">selects</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="there.Bins" href="#there.Bins">Bins</a></code></h4>
<ul class="">
<li><code><a title="there.Bins.nums" href="#there.Bins.nums">nums</a></code></li>
<li><code><a title="there.Bins.syms" href="#there.Bins.syms">syms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="there.Row" href="#there.Row">Row</a></code></h4>
<ul class="">
<li><code><a title="there.Row.better" href="#there.Row.better">better</a></code></li>
<li><code><a title="there.Row.dist" href="#there.Row.dist">dist</a></code></li>
<li><code><a title="there.Row.status" href="#there.Row.status">status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="there.Rows" href="#there.Rows">Rows</a></code></h4>
<ul class="">
<li><code><a title="there.Rows.add" href="#there.Rows.add">add</a></code></li>
<li><code><a title="there.Rows.bins" href="#there.Rows.bins">bins</a></code></li>
<li><code><a title="there.Rows.ch" href="#there.Rows.ch">ch</a></code></li>
<li><code><a title="there.Rows.header" href="#there.Rows.header">header</a></code></li>
<li><code><a title="there.Rows.row" href="#there.Rows.row">row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="there.Seen" href="#there.Seen">Seen</a></code></h4>
<ul class="">
<li><code><a title="there.Seen.fields" href="#there.Seen.fields">fields</a></code></li>
<li><code><a title="there.Seen.known" href="#there.Seen.known">known</a></code></li>
<li><code><a title="there.Seen.likes" href="#there.Seen.likes">likes</a></code></li>
<li><code><a title="there.Seen.train" href="#there.Seen.train">train</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="there.o" href="#there.o">o</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>